package main

import (
	"archive/zip"
	"bytes" // Import the bytes package
	"database/sql"
	"encoding/json"
	"fmt"
	"io"
	"io/ioutil"
	"log"
	"net/http"
	"os"
	"strings"

	"github.com/joho/godotenv"
	_ "github.com/lib/pq"
)

type CVE struct {
	Metadata CVEMetadata `json:"cveMetadata"`
	// Add other necessary fields
}

type CVEMetadata struct {
	AssignerOrgID     string `json:"assignerOrgId"`
	AssignerShortName string `json:"assignerShortName"`
	CVEID             string `json:"cveId"`
	DatePublished     string `json:"datePublished"`
	DateReserved      string `json:"dateReserved"`
	DateUpdated       string `json:"dateUpdated"`
	State             string `json:"state"`
}

func main() {
	err := godotenv.Load()
	if err != nil {
		log.Fatalf("Error loading .env file: %v", err)
	}
	db, err := sql.Open("postgres", fmt.Sprintf("host=%s port=%s user=%s password=%s dbname=%s sslmode=disable search_path=%s",
		os.Getenv("DB_HOST"), os.Getenv("DB_PORT"), os.Getenv("DB_USER"), os.Getenv("DB_PASSWORD"), os.Getenv("DB_NAME"), os.Getenv("DB_SCHEMA")))
	fmt.Println(os.Getenv("DB_HOST"), os.Getenv("DB_PORT"), os.Getenv("DB_USER"), os.Getenv("DB_PASSWORD"), os.Getenv("DB_NAME"), os.Getenv("DB_SCHEMA"))
	if err != nil {
		log.Fatalf("Failed to connect to the database: %v", err)
	} else {
		fmt.Println("DB success")
	}
	fmt.Println(os.Getenv("DB_SCHEMA"))
	_, err = db.Exec("SET search_path='cve'")
	if err != nil {
		fmt.Println(err)
	}
	defer db.Close()

	// Create table if not exists
	// createTableQuery := `
	// CREATE TABLE IF NOT EXISTS cves (
	//     id SERIAL PRIMARY KEY,
	//     cve_id TEXT,
	//     data JSONB,
	//     version INTEGER,
	//     UNIQUE(cve_id, version)
	// );
	// `
	// if _, err := db.Exec(createTableQuery); err != nil {
	// 	log.Fatalf("Failed to create table: %v", err)
	// }

	// Process the local CVE zip file
	// err = processCVEZipFile(db, "cvelistV5-main.zip")
	// if err != nil {
	// 	log.Fatalf("Failed to process CVE zip file: %v", err)
	// }

	// URL of the zip file
	url := "https://github.com/CVEProject/cvelistV5/archive/refs/heads/main.zip"

	zipBytes, err := downloadFile(url)
	if err != nil {
		log.Fatalf("Failed to download CVE zip file: %v", err)
	}

	err = processCVEZipFile(db, zipBytes)
	if err != nil {
		log.Fatalf("Failed to process CVE zip file: %v", err)
	}
}

// downloadFile downloads a file from the given URL and returns the file's bytes
func downloadFile(url string) ([]byte, error) {
	resp, err := http.Get(url)
	if err != nil {
		return nil, fmt.Errorf("failed to download file: %v", err)
	}
	defer resp.Body.Close()

	if resp.StatusCode != http.StatusOK {
		return nil, fmt.Errorf("failed to download file: %v", resp.Status)
	}

	buf := new(bytes.Buffer)
	_, err = io.Copy(buf, resp.Body)
	if err != nil {
		return nil, fmt.Errorf("failed to read response body: %v", err)
	}

	return buf.Bytes(), nil
}

func processCVEZipFile(db *sql.DB, zipBytes []byte) error {
	reader, err := zip.NewReader(bytes.NewReader(zipBytes), int64(len(zipBytes)))
	if err != nil {
		return fmt.Errorf("failed to create zip reader: %v", err)
	}

	for _, file := range reader.File {
		if !file.FileInfo().IsDir() && strings.HasSuffix(file.Name, ".json") && strings.HasPrefix(file.Name, "cvelistV5-main/cves/") {
			err := processCVEFile(db, file)
			if err != nil {
				log.Printf("Failed to process file %s: %v", file.Name, err)
			}
			println("Processed file: ", file.Name)
		}
	}
	return nil
}

func processCVEFile(db *sql.DB, file *zip.File) error {
	// Open the file inside the zip archive
	fileReader, err := file.Open()
	if err != nil {
		return fmt.Errorf("failed to open file %s: %v", file.Name, err)
	}
	defer fileReader.Close()

	// Read the file contents
	content, err := ioutil.ReadAll(fileReader)
	if err != nil {
		return fmt.Errorf("failed to read file %s: %v", file.Name, err)
	}

	// Unmarshal the JSON data
	var cve CVE
	if err := json.Unmarshal(content, &cve); err != nil {
		return fmt.Errorf("failed to unmarshal JSON in file %s: %v", file.Name, err)
	}

	// Insert the CVE into the database
	return insertCVE(db, cve)
}

func insertCVE(db *sql.DB, cve CVE) error {
	version := getVersion(cve)
	cveJSON, err := json.Marshal(cve)
	if err != nil {
		return fmt.Errorf("failed to marshal CVE: %v", err)
	}

	insertQuery := `
    INSERT INTO cve.cves (cve_id, data, version)
    VALUES ($1, $2, $3)
    ON CONFLICT (cve_id, version) DO NOTHING;
    `
	if _, err := db.Exec(insertQuery, cve.Metadata.CVEID, cveJSON, version); err != nil {
		return fmt.Errorf("failed to insert CVE: %v", err)
	}
	return nil
}

func getVersion(cve CVE) int {
	// Implement versioning logic based on dateUpdated or other criteria
	return 1
}
