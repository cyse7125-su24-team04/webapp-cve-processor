package main

import (
	"archive/zip"
	"database/sql"
	"encoding/json"
	"fmt"
	"io/ioutil"
	"log"
	"os"
	"strings"

	_ "github.com/lib/pq"
)

type CVE struct {
	Metadata CVEMetadata `json:"cveMetadata"`
	// Add other necessary fields
}

type CVEMetadata struct {
	AssignerOrgID     string `json:"assignerOrgId"`
	AssignerShortName string `json:"assignerShortName"`
	CVEID             string `json:"cveId"`
	DatePublished     string `json:"datePublished"`
	DateReserved      string `json:"dateReserved"`
	DateUpdated       string `json:"dateUpdated"`
	State             string `json:"state"`
}

func main() {
	db, err := sql.Open("postgres", fmt.Sprintf("host=%s port=%s user=%s password=%s dbname=%s sslmode=disable",
		os.Getenv("DB_HOST"), os.Getenv("DB_PORT"), os.Getenv("DB_USER"), os.Getenv("DB_PASSWORD"), os.Getenv("DB_NAME")))
	if err != nil {
		log.Fatalf("Failed to connect to the database: %v", err)
	}
	defer db.Close()

	// Create table if not exists
	createTableQuery := `
    CREATE TABLE IF NOT EXISTS cves (
        id SERIAL PRIMARY KEY,
        cve_id TEXT,
        data JSONB,
        version INTEGER,
        UNIQUE(cve_id, version)
    );
    `
	if _, err := db.Exec(createTableQuery); err != nil {
		log.Fatalf("Failed to create table: %v", err)
	}

	// Process the local CVE zip file
	err = processCVEZipFile(db, "cvelistV5-main.zip")
	if err != nil {
		log.Fatalf("Failed to process CVE zip file: %v", err)
	}
}

func processCVEZipFile(db *sql.DB, zipFilePath string) error {
	// Unzip the file
	zipReader, err := zip.OpenReader(zipFilePath)
	if err != nil {
		return fmt.Errorf("failed to open zip file: %v", err)
	}
	defer zipReader.Close()

	// Iterate over the files in the zip archive
	for _, file := range zipReader.File {
		// println(file.Name) //cvelistV5-main/cves/2020/0xxx/CVE-2020-0735.json
		// skip file if it is not a JSON file and does not have the expected suffix and prefix (cves/2020/0xxx/)
		if !file.FileInfo().IsDir() && strings.HasSuffix(file.Name, ".json") && strings.HasPrefix(file.Name, "cvelistV5-main/cves/2024/0xxx/") {
			err := processCVEFile(db, file)
			if err != nil {
				log.Printf("Failed to process file %s: %v", file.Name, err)
			}
			println("Processed file: ", file.Name)
		}
	}
	return nil
}

func processCVEFile(db *sql.DB, file *zip.File) error {
	// Open the file inside the zip archive
	fileReader, err := file.Open()
	if err != nil {
		return fmt.Errorf("failed to open file %s: %v", file.Name, err)
	}
	defer fileReader.Close()

	// Read the file contents
	content, err := ioutil.ReadAll(fileReader)
	if err != nil {
		return fmt.Errorf("failed to read file %s: %v", file.Name, err)
	}

	// Unmarshal the JSON data
	var cve CVE
	if err := json.Unmarshal(content, &cve); err != nil {
		return fmt.Errorf("failed to unmarshal JSON in file %s: %v", file.Name, err)
	}

	// Insert the CVE into the database
	return insertCVE(db, cve)
}

func insertCVE(db *sql.DB, cve CVE) error {
	version := getVersion(cve)
	cveJSON, err := json.Marshal(cve)
	if err != nil {
		return fmt.Errorf("failed to marshal CVE: %v", err)
	}

	insertQuery := `
    INSERT INTO cves (cve_id, data, version)
    VALUES ($1, $2, $3)
    ON CONFLICT (cve_id, version) DO NOTHING;
    `
	if _, err := db.Exec(insertQuery, cve.Metadata.CVEID, cveJSON, version); err != nil {
		return fmt.Errorf("failed to insert CVE: %v", err)
	}
	return nil
}

func getVersion(cve CVE) int {
	// Implement versioning logic based on dateUpdated or other criteria
	return 1
}
