// cmd/webapp/main.go
package main

import (
	"archive/zip"
	"bytes"
	"database/sql"
	"encoding/json"
	"fmt"
	"io"
	"io/ioutil"
	"net/http"
	"os"
	"path/filepath"
	"strings"
	"time"

	"github.com/joho/godotenv"
	_ "github.com/lib/pq"
)

const (
	cveListURL = "https://github.com/CVEProject/cvelistV5/archive/refs/heads/main.zip"
	outputDir  = "./cvelist"
)

type CVERecord struct {
	// Define the structure based on the provided JSON schema
	CVEDataType    string `json:"CVE_data_type"`
	CVEDataFormat  string `json:"CVE_data_format"`
	CVEDataVersion string `json:"CVE_data_version"`
	CVEDataMeta    struct {
		ID                string `json:"cveId"`
		AssignerOrgID     string `json:"assignerOrgId"`
		AssignerShortName string `json:"assignerShortName"`
		DatePublished     string `json:"datePublished"`
		DateReserved      string `json:"dateReserved"`
		DateUpdated       string `json:"dateUpdated"`
		State             string `json:"state"`
	} `json:"cveMetadata"`
	Containers struct {
		CNA struct {
			ProviderMetadata struct {
				OrgID     string `json:"orgId"`
				ShortName string `json:"shortName"`
			} `json:"providerMetadata"`
			Title        string `json:"title"`
			Descriptions []struct {
				Lang  string `json:"lang"`
				Value string `json:"value"`
			} `json:"descriptions"`
			Affected []struct {
				Product string `json:"product"`
				Version string `json:"version"`
			} `json:"affected"`
		} `json:"cna"`
	} `json:"containers"`
}

// downloadFile downloads a file from the given URL and returns the file's bytes
func downloadFile(url string) ([]byte, error) {
	// func downloadFile(url, filepath string) error {
	resp, err := http.Get(url)
	if err != nil {
		return nil, fmt.Errorf("failed to download file: %v", err)
	}
	defer resp.Body.Close()

	if resp.StatusCode != http.StatusOK {
		return nil, fmt.Errorf("failed to download file: %v", resp.Status)
	}
	buf := new(bytes.Buffer)
	_, err = io.Copy(buf, resp.Body)
	if err != nil {
		return nil, fmt.Errorf("failed to read response body: %v", err)
	}

	// out, err := os.Create(filepath)
	// if err != nil {
	// 	return err
	// }
	// defer out.Close()
	// _, err = io.Copy(out, resp.Body)
	// return err
	return buf.Bytes(), nil
}

func unzip(src, dest string) error {
	r, err := zip.OpenReader(src)
	if err != nil {
		return err
	}
	defer r.Close()

	for _, f := range r.File {
		fpath := filepath.Join(dest, f.Name)
		if !strings.HasPrefix(fpath, filepath.Clean(dest)+string(os.PathSeparator)) {
			return fmt.Errorf("illegal file path: %s", fpath)
		}

		if f.FileInfo().IsDir() {
			os.MkdirAll(fpath, os.ModePerm)
			continue
		}

		if err := os.MkdirAll(filepath.Dir(fpath), os.ModePerm); err != nil {
			return err
		}

		outFile, err := os.OpenFile(fpath, os.O_WRONLY|os.O_CREATE|os.O_TRUNC, f.Mode())
		if err != nil {
			return err
		}

		rc, err := f.Open()
		if err != nil {
			return err
		}

		_, err = io.Copy(outFile, rc)

		outFile.Close()
		rc.Close()

		if err != nil {
			return err
		}
	}
	return nil
}

func processJSONFiles(db *sql.DB, dir string) error {
	err := filepath.Walk(dir, func(path string, info os.FileInfo, err error) error {
		if err != nil {
			return err
		}

		if !info.IsDir() && strings.HasSuffix(info.Name(), ".json") {
			file, err := os.Open(path)
			// print("Processing file: " + path + "\n")
			if err != nil {
				return err
			}
			defer file.Close()

			var record CVERecord
			decoder := json.NewDecoder(file)
			err = decoder.Decode(&record)
			if err != nil {
				return err
			}

			datePublished, err := time.Parse(time.RFC3339, record.CVEDataMeta.DatePublished)
			if err != nil {
				datePublished = time.Time{}
			}
			dateUpdated, err := time.Parse(time.RFC3339, record.CVEDataMeta.DateUpdated)
			if err != nil {
				dateUpdated = time.Time{}
			}

			jsonData, err := json.Marshal(record)
			if err != nil {
				return err
			}
			println("Inserting record: " + string(jsonData))
			_, err = db.Exec(`INSERT INTO cve.records (cve_id, data, date_published, date_updated) VALUES ($1, $2, $3, $4)
                ON CONFLICT (cve_id) DO UPDATE SET data = EXCLUDED.data, date_published = EXCLUDED.date_published, date_updated = EXCLUDED.date_updated`,
				record.CVEDataMeta.ID, jsonData, datePublished, dateUpdated)
			if err != nil {
				return err
			}
		}

		return nil
	})
	return err
}

// func processCVEZipFile(db *sql.DB, zipFilePath string) error {
func processCVEZipFile(db *sql.DB, zipBytes []byte) error {
	reader, err := zip.NewReader(bytes.NewReader(zipBytes), int64(len(zipBytes)))
	if err != nil {
		return fmt.Errorf("failed to create zip reader: %v", err)
	}
	// Unzip the file
	// zipReader, err := zip.OpenReader(zipFilePath)
	// if err != nil {
	// 	return fmt.Errorf("failed to open zip file: %v", err)
	// }
	// defer zipReader.Close()

	// Regex to match CVE file naming format
	// cveFilePattern := regexp.MustCompile(`.*/CVE-\d{4}-\d{4}\.json`)

	// Iterate over the files in the zip archive
	// for _, file := range zipReader.File {
	for _, file := range reader.File {
		// if !file.FileInfo().IsDir() && cveFilePattern.MatchString(file.Name) {
		if !file.FileInfo().IsDir() && strings.HasSuffix(file.Name, ".json") && strings.HasPrefix(file.Name, "cvelistV5-main/cves/") {
			err := processCVEFile(db, file)
			if err != nil {
				fmt.Print("Failed to process file: ", file.Name, err)
			}
			println("Processed file: " + file.Name)
		}
	}
	return nil
}

func processCVEFile(db *sql.DB, file *zip.File) error {
	// Open the file inside the zip archive
	print("Processing file: " + file.Name + "\n")
	fileReader, err := file.Open()
	if err != nil {
		return fmt.Errorf("failed to open file %s: %v", file.Name, err)
	}
	defer fileReader.Close()

	// Read the file contents
	content, err := ioutil.ReadAll(fileReader)
	if err != nil {
		return fmt.Errorf("failed to read file %s: %v", file.Name, err)
	}

	// Unmarshal the JSON data
	var cve CVERecord
	if err := json.Unmarshal(content, &cve); err != nil {
		return fmt.Errorf("failed to unmarshal JSON in file %s: %v", file.Name, err)
	}

	// Insert the CVE into the database
	return insertCVE(db, cve)
}

func insertCVE(db *sql.DB, cve CVERecord) error {
	// version := getVersion(cve)
	cveJSON, err := json.Marshal(cve)
	if err != nil {
		return fmt.Errorf("failed to marshal CVE: %v", err)
	}

	// INSERT INTO cve.cves (cve_id, data, version)
	// VALUES ($1, $2, $3)
	// ON CONFLICT (cve_id, version) DO NOTHING;

	insertQuery := `
    INSERT INTO cve.cves (cve_id, data)
    VALUES ($1, $2)
    ON CONFLICT (cve_id) DO UPDATE SET data = EXCLUDED.data;
    `
	// if _, err := db.Exec(insertQuery, cve.Metadata.CVEID, cveJSON, version); err != nil {
	if _, err := db.Exec(insertQuery, cve.CVEDataMeta.ID, cveJSON); err != nil {
		return fmt.Errorf("failed to insert CVE: %v", err)
	}
	return nil
}

// func getVersion(cve CVERecord) int {
// 	// versioning
// 	return 1
// }

func main() {
	godotenv.Load()
	// println(os.Getenv("TEST"))
	fmt.Println("Downloading CVE list...")
	zipBytes, err := downloadFile(cveListURL)
	if err != nil {
		fmt.Printf("Error downloading CVE list: %v\n", err)
		return
	}
	// fmt.Println("Unzipping CVE list...")
	// err = unzip("cvelist.zip", outputDir)
	// if err != nil {
	// 	fmt.Printf("Error unzipping CVE list: %v\n", err)
	// 	return
	// }

	fmt.Println("Connecting to PostgreSQL database...")
	// connStr := "user=postgres dbname=cve sslmode=disable"
	connStr := fmt.Sprintf("host=%s port=%s user=%s password=%s dbname=%s sslmode=disable", os.Getenv("DB_HOST"), os.Getenv("DB_PORT"), os.Getenv("DB_USER"), os.Getenv("DB_PASSWORD"), os.Getenv("DB_NAME"))
	db, err := sql.Open("postgres", connStr)
	if err != nil {
		fmt.Printf("Error connecting to database: %v\n", err)
		// log.Fatalf("Failed to connect to the database: %v", err)
		return
	}
	defer db.Close()

	fmt.Println("Processing JSON files...")
	// err = processJSONFiles(db, outputDir)
	// err = processCVEZipFile(db, ".cvelist.zip")
	// err = processCVEZipFile(db, "cvelistV5-main.zip")
	err = processCVEZipFile(db, zipBytes)
	if err != nil {
		fmt.Printf("Error processing JSON files: %v\n", err)
		return
	}
	fmt.Println("CVE records processed successfully.")
}
